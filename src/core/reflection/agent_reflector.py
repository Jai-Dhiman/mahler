"""Per-Agent Self-Reflection System.

Implements the TradingGroup paper's per-agent reflection mechanism where each
agent type generates specialized reflections on its past performance:

1. ForecastingReflector: Analyzes prediction accuracy patterns
2. StyleReflector: Correlates trading style choices with outcomes
3. DecisionReflector: Labels past entry decisions as good/bad

These reflections feed back into the learning loop, enabling each agent
to improve based on its specific role in the trading pipeline.
"""

from __future__ import annotations

import json
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

if TYPE_CHECKING:
    from core.ai.claude import ClaudeClient


class ReflectorType(str, Enum):
    """Types of agent reflectors."""

    FORECASTING = "forecasting"
    STYLE = "style"
    DECISION = "decision"


@dataclass
class PatternAnalysis:
    """Analysis of success/failure patterns."""

    conditions: list[str]  # Market conditions where pattern applies
    frequency: int  # How often this pattern occurred
    success_rate: float  # Win rate when pattern present
    avg_pnl_percent: float  # Average P&L when pattern present
    examples: list[str]  # Example trade IDs

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "conditions": self.conditions,
            "frequency": self.frequency,
            "success_rate": self.success_rate,
            "avg_pnl_percent": self.avg_pnl_percent,
            "examples": self.examples,
        }


@dataclass
class AgentReflection:
    """Reflection generated by an agent reflector."""

    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    agent_type: ReflectorType = ReflectorType.FORECASTING
    generated_at: str = field(default_factory=lambda: datetime.now().isoformat())
    lookback_days: int = 30
    trade_count: int = 0
    success_patterns: list[PatternAnalysis] = field(default_factory=list)
    failure_patterns: list[PatternAnalysis] = field(default_factory=list)
    key_insights: list[str] = field(default_factory=list)
    recommended_adjustments: str = ""

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "id": self.id,
            "agent_type": self.agent_type.value,
            "generated_at": self.generated_at,
            "lookback_days": self.lookback_days,
            "trade_count": self.trade_count,
            "success_patterns": [p.to_dict() for p in self.success_patterns],
            "failure_patterns": [p.to_dict() for p in self.failure_patterns],
            "key_insights": self.key_insights,
            "recommended_adjustments": self.recommended_adjustments,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "AgentReflection":
        """Deserialize from dictionary."""
        success_patterns = [
            PatternAnalysis(**p) for p in data.get("success_patterns", [])
        ]
        failure_patterns = [
            PatternAnalysis(**p) for p in data.get("failure_patterns", [])
        ]

        return cls(
            id=data.get("id", str(uuid.uuid4())),
            agent_type=ReflectorType(data.get("agent_type", "forecasting")),
            generated_at=data.get("generated_at", datetime.now().isoformat()),
            lookback_days=data.get("lookback_days", 30),
            trade_count=data.get("trade_count", 0),
            success_patterns=success_patterns,
            failure_patterns=failure_patterns,
            key_insights=data.get("key_insights", []),
            recommended_adjustments=data.get("recommended_adjustments", ""),
        )


# Prompts for reflection generation

FORECASTING_REFLECTOR_SYSTEM = """You are analyzing the forecasting accuracy of a trading system's predictions.
Your goal is to identify patterns in when predictions were accurate vs inaccurate.

Focus on:
1. Market conditions that correlate with accurate predictions
2. Conditions that consistently led to prediction errors
3. Confidence calibration (were high-confidence predictions more accurate?)
4. Direction vs magnitude accuracy

Be specific and actionable. Identify concrete patterns."""

FORECASTING_REFLECTOR_USER = """Analyze these {trade_count} trades from the past {lookback_days} days for forecasting patterns:

{trade_summaries}

Generate a reflection on forecasting accuracy.

Respond in JSON:
{{
    "success_patterns": [
        {{
            "conditions": ["condition 1", "condition 2"],
            "frequency": 5,
            "success_rate": 0.80,
            "avg_pnl_percent": 0.15,
            "examples": ["trade_id_1", "trade_id_2"]
        }}
    ],
    "failure_patterns": [
        {{
            "conditions": ["condition 1"],
            "frequency": 3,
            "success_rate": 0.20,
            "avg_pnl_percent": -0.10,
            "examples": ["trade_id_3"]
        }}
    ],
    "key_insights": ["insight 1", "insight 2"],
    "recommended_adjustments": "What the forecasting agents should do differently"
}}"""

STYLE_REFLECTOR_SYSTEM = """You are analyzing the correlation between trading style choices and outcomes.
Your goal is to identify which styles perform best under which conditions.

Focus on:
1. When conservative style outperformed aggressive
2. When aggressive style was optimal
3. VIX levels and optimal style
4. Regime-style correlations

Be specific about the conditions that favor each style."""

STYLE_REFLECTOR_USER = """Analyze these {trade_count} trades for style-outcome patterns:

{trade_summaries}

Each trade shows the style used and the outcome.

Respond in JSON:
{{
    "success_patterns": [
        {{
            "conditions": ["VIX < 20", "bullish regime"],
            "frequency": 8,
            "success_rate": 0.85,
            "avg_pnl_percent": 0.12,
            "examples": ["trade_id_1"]
        }}
    ],
    "failure_patterns": [
        {{
            "conditions": ["aggressive style in VIX > 25"],
            "frequency": 4,
            "success_rate": 0.25,
            "avg_pnl_percent": -0.15,
            "examples": ["trade_id_2"]
        }}
    ],
    "key_insights": ["insight 1", "insight 2"],
    "recommended_adjustments": "How to adjust style selection logic"
}}"""

DECISION_REFLECTOR_SYSTEM = """You are analyzing entry decisions to identify which types of trades succeeded or failed.
Your goal is to label past decisions as good/bad based on outcomes and extract learnings.

Focus on:
1. Entry criteria that led to wins
2. Warning signs that preceded losses
3. Debates where the losing side had better arguments
4. Context factors that should have blocked entry

Be specific about actionable rules."""

DECISION_REFLECTOR_USER = """Analyze these {trade_count} entry decisions from the past {lookback_days} days:

{trade_summaries}

Label each decision and identify patterns.

Respond in JSON:
{{
    "success_patterns": [
        {{
            "conditions": ["high IV rank", "term structure contango"],
            "frequency": 6,
            "success_rate": 0.90,
            "avg_pnl_percent": 0.18,
            "examples": ["trade_id_1"]
        }}
    ],
    "failure_patterns": [
        {{
            "conditions": ["entered despite bear concerns", "low conviction"],
            "frequency": 5,
            "success_rate": 0.20,
            "avg_pnl_percent": -0.12,
            "examples": ["trade_id_2"]
        }}
    ],
    "key_insights": ["insight 1", "insight 2"],
    "recommended_adjustments": "Rules to add or modify for entry decisions"
}}"""


class BaseReflector:
    """Base class for agent reflectors."""

    reflector_type: ReflectorType = ReflectorType.FORECASTING

    def __init__(self, claude: ClaudeClient):
        """Initialize the reflector.

        Args:
            claude: Claude client for generating reflections
        """
        self.claude = claude

    async def generate_reflection(
        self,
        trades: list[dict],
        lookback_days: int = 30,
    ) -> AgentReflection:
        """Generate a reflection based on recent trades.

        Args:
            trades: List of trade dictionaries with outcome data
            lookback_days: Number of days of history analyzed

        Returns:
            AgentReflection with patterns and insights
        """
        raise NotImplementedError("Subclasses must implement generate_reflection")

    def _format_trade_summaries(self, trades: list[dict]) -> str:
        """Format trades for inclusion in prompts."""
        summaries = []
        for t in trades[:20]:  # Limit to 20 for context length
            summary = (
                f"- {t.get('underlying', 'UNK')} ({t.get('spread_type', 'UNK')}): "
                f"P&L {t.get('pnl_percent', 0):.1%}, "
                f"Exit: {t.get('exit_reason', 'UNK')}, "
                f"Style: {t.get('trading_style', 'UNK')}, "
                f"VIX: {t.get('vix', 'N/A')}, "
                f"Regime: {t.get('regime', 'UNK')}, "
                f"Confidence: {t.get('confidence', 0):.0%}, "
                f"ID: {t.get('trade_id', 'UNK')[:8]}"
            )
            summaries.append(summary)
        return "\n".join(summaries)

    def _parse_reflection_response(
        self,
        response: str,
        trade_count: int,
        lookback_days: int,
    ) -> AgentReflection:
        """Parse Claude's response into an AgentReflection."""
        data = self.claude._parse_json_response(response)

        success_patterns = [
            PatternAnalysis(
                conditions=p.get("conditions", []),
                frequency=p.get("frequency", 0),
                success_rate=p.get("success_rate", 0),
                avg_pnl_percent=p.get("avg_pnl_percent", 0),
                examples=p.get("examples", []),
            )
            for p in data.get("success_patterns", [])
        ]

        failure_patterns = [
            PatternAnalysis(
                conditions=p.get("conditions", []),
                frequency=p.get("frequency", 0),
                success_rate=p.get("success_rate", 0),
                avg_pnl_percent=p.get("avg_pnl_percent", 0),
                examples=p.get("examples", []),
            )
            for p in data.get("failure_patterns", [])
        ]

        return AgentReflection(
            agent_type=self.reflector_type,
            lookback_days=lookback_days,
            trade_count=trade_count,
            success_patterns=success_patterns,
            failure_patterns=failure_patterns,
            key_insights=data.get("key_insights", []),
            recommended_adjustments=data.get("recommended_adjustments", ""),
        )


class ForecastingReflector(BaseReflector):
    """Reflector for forecasting/prediction accuracy analysis.

    Analyzes patterns in prediction accuracy:
    - When were directional forecasts correct?
    - What conditions led to prediction errors?
    - Is confidence calibration accurate?
    """

    reflector_type = ReflectorType.FORECASTING

    async def generate_reflection(
        self,
        trades: list[dict],
        lookback_days: int = 30,
    ) -> AgentReflection:
        """Generate forecasting accuracy reflection."""
        if not trades:
            return AgentReflection(
                agent_type=self.reflector_type,
                lookback_days=lookback_days,
                trade_count=0,
                key_insights=["Insufficient data for forecasting analysis"],
            )

        trade_summaries = self._format_trade_summaries(trades)

        prompt = FORECASTING_REFLECTOR_USER.format(
            trade_count=len(trades),
            lookback_days=lookback_days,
            trade_summaries=trade_summaries,
        )

        response = await self.claude._request(
            [{"role": "user", "content": prompt}],
            FORECASTING_REFLECTOR_SYSTEM,
        )

        return self._parse_reflection_response(response, len(trades), lookback_days)


class StyleReflector(BaseReflector):
    """Reflector for trading style vs outcome analysis.

    Analyzes which trading styles work best under which conditions:
    - Aggressive vs conservative performance by VIX level
    - Style effectiveness by market regime
    - Optimal style transitions
    """

    reflector_type = ReflectorType.STYLE

    async def generate_reflection(
        self,
        trades: list[dict],
        lookback_days: int = 30,
    ) -> AgentReflection:
        """Generate style-outcome reflection."""
        if not trades:
            return AgentReflection(
                agent_type=self.reflector_type,
                lookback_days=lookback_days,
                trade_count=0,
                key_insights=["Insufficient data for style analysis"],
            )

        trade_summaries = self._format_trade_summaries(trades)

        prompt = STYLE_REFLECTOR_USER.format(
            trade_count=len(trades),
            trade_summaries=trade_summaries,
        )

        response = await self.claude._request(
            [{"role": "user", "content": prompt}],
            STYLE_REFLECTOR_SYSTEM,
        )

        return self._parse_reflection_response(response, len(trades), lookback_days)


class DecisionReflector(BaseReflector):
    """Reflector for entry decision quality analysis.

    Labels past entry decisions and extracts learnings:
    - Which entry criteria led to success?
    - What warning signs preceded losses?
    - Should certain trades have been skipped?
    """

    reflector_type = ReflectorType.DECISION

    async def generate_reflection(
        self,
        trades: list[dict],
        lookback_days: int = 30,
    ) -> AgentReflection:
        """Generate decision quality reflection."""
        if not trades:
            return AgentReflection(
                agent_type=self.reflector_type,
                lookback_days=lookback_days,
                trade_count=0,
                key_insights=["Insufficient data for decision analysis"],
            )

        trade_summaries = self._format_trade_summaries(trades)

        prompt = DECISION_REFLECTOR_USER.format(
            trade_count=len(trades),
            lookback_days=lookback_days,
            trade_summaries=trade_summaries,
        )

        response = await self.claude._request(
            [{"role": "user", "content": prompt}],
            DECISION_REFLECTOR_SYSTEM,
        )

        return self._parse_reflection_response(response, len(trades), lookback_days)


class AgentReflectorManager:
    """Manager for coordinating per-agent reflections.

    Orchestrates all three reflector types and stores results.
    """

    def __init__(self, claude: ClaudeClient, d1_binding: Any = None):
        """Initialize the reflector manager.

        Args:
            claude: Claude client for generating reflections
            d1_binding: Optional D1 binding for storing reflections
        """
        self.claude = claude
        self.db = d1_binding

        self.forecasting_reflector = ForecastingReflector(claude)
        self.style_reflector = StyleReflector(claude)
        self.decision_reflector = DecisionReflector(claude)

    async def generate_all_reflections(
        self,
        trades: list[dict],
        lookback_days: int = 30,
    ) -> dict[ReflectorType, AgentReflection]:
        """Generate reflections from all agent types.

        Args:
            trades: List of trade dictionaries with outcome data
            lookback_days: Number of days of history analyzed

        Returns:
            Dictionary mapping reflector types to their reflections
        """
        reflections = {}

        # Generate each type of reflection
        reflections[ReflectorType.FORECASTING] = await self.forecasting_reflector.generate_reflection(
            trades, lookback_days
        )

        reflections[ReflectorType.STYLE] = await self.style_reflector.generate_reflection(
            trades, lookback_days
        )

        reflections[ReflectorType.DECISION] = await self.decision_reflector.generate_reflection(
            trades, lookback_days
        )

        # Store reflections if DB is available
        if self.db is not None:
            for reflection in reflections.values():
                await self._store_reflection(reflection)

        return reflections

    async def _store_reflection(self, reflection: AgentReflection) -> None:
        """Store a reflection in the database."""
        await self.db.prepare(
            """
            INSERT INTO agent_reflections (
                id, agent_type, generated_at, lookback_days, trade_count,
                success_patterns, failure_patterns, key_insights,
                recommended_adjustments, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
            """
        ).bind(
            reflection.id,
            reflection.agent_type.value,
            reflection.generated_at,
            reflection.lookback_days,
            reflection.trade_count,
            json.dumps([p.to_dict() for p in reflection.success_patterns]),
            json.dumps([p.to_dict() for p in reflection.failure_patterns]),
            json.dumps(reflection.key_insights),
            reflection.recommended_adjustments,
        ).run()

    async def get_recent_reflections(
        self,
        agent_type: ReflectorType | None = None,
        limit: int = 10,
    ) -> list[AgentReflection]:
        """Get recent reflections from the database.

        Args:
            agent_type: Optional filter by reflector type
            limit: Maximum number to return

        Returns:
            List of AgentReflection objects
        """
        if self.db is None:
            return []

        if agent_type:
            rows = await self.db.prepare(
                """
                SELECT * FROM agent_reflections
                WHERE agent_type = ?
                ORDER BY generated_at DESC
                LIMIT ?
                """
            ).bind(agent_type.value, limit).all()
        else:
            rows = await self.db.prepare(
                """
                SELECT * FROM agent_reflections
                ORDER BY generated_at DESC
                LIMIT ?
                """
            ).bind(limit).all()

        reflections = []
        for row in rows.results:
            reflection = AgentReflection(
                id=row["id"],
                agent_type=ReflectorType(row["agent_type"]),
                generated_at=row["generated_at"],
                lookback_days=row["lookback_days"],
                trade_count=row["trade_count"],
                success_patterns=[
                    PatternAnalysis(**p)
                    for p in json.loads(row.get("success_patterns") or "[]")
                ],
                failure_patterns=[
                    PatternAnalysis(**p)
                    for p in json.loads(row.get("failure_patterns") or "[]")
                ],
                key_insights=json.loads(row.get("key_insights") or "[]"),
                recommended_adjustments=row.get("recommended_adjustments", ""),
            )
            reflections.append(reflection)

        return reflections
